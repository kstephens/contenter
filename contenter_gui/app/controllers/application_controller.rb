# Filters added to this controller apply to all controllers in the application.
# Likewise, all the methods added will be available for all controllers.

class ApplicationController < ActionController::Base
  include AuthenticatedSystem
  include RoleRequirementSystem
  include CapabilityRequirementSystem
  include SessionVersionList

  before_filter :reset_model_cache!
  before_filter :auth_cache_check!
  before_filter :track_user!
  around_filter :check_for_auth_error!
  
=begin
  before_filter :log_authentication!
  after_filter :log_authentication!
  def log_authentication!
    $stderr.puts "current_user = #{current_user.inspect}"
    $stderr.puts "real_user = #{real_user.inspect}"
    $stderr.puts "session[:user_id] = #{session[:user_id].inspect}"
    $stderr.puts "session[:real_user_id] = #{session[:real_user_id].inspect}"
    true
  end
=end

  helper :all # include all helpers, all the time

  # See ActionController::RequestForgeryProtection for details
  # Uncomment the :secret if you're not using the cookie session store
  protect_from_forgery :secret => '4181fa48888dd663ae6eb0d5843778ef'

  # See ActionController::Base for details 
  # Uncomment this to filter the contents of submitted sensitive data parameters
  # from your application log (in this case, all fields with names like "password"). 
  filter_parameter_logging :password


  ####################################################################
  # Controller/view/model support
  #

  before_filter :track_controller!
  def track_controller!
    Thread.current[:'ApplicationController.current'] = self
  end
  private :track_controller!

  # Making Rails think these autogenerated models were autoloaded is the alternative to monkey patching
  # AR to keep from screwing the implementations of these classes up upon successive http requests
  if RAILS_ENV=='development'
    before_filter do 
      ['ContentVersion', 'Content::Version', 'ContentKeyVersion', 'ContentKey::Version'].each do |klass|
        unless ActiveSupport::Dependencies.autoloaded_constants.include? klass
          ActiveSupport::Dependencies.autoloaded_constants << klass
        end
      end
    end
  end

  def self.current
    Thread.current[:'ApplicationController.current']
  end

  # Require that destructive operations be via POST
  before_filter :require_post, :only => [ :create, :update ]
  def require_post
    unless request.post? || request.put?
      logger.error "Request #{request.url} was requested via GET but required to be a POST"
      render(:text => "Not allowed to invoke #{params.inspect} via GET", :status => :method_not_allowed) 
    end
  end

  ####################################################################
  # ModelCache support
  #


  def reset_model_cache!
    ModelCache.reset!
    ModelCache.create!
  end
  helper_method :reset_model_cache!
  
 

  ####################################################################
  # Auth support
  #

  def access_denied msg = nil
    flash[:error] = "Not Authorized"
    @error_message = msg
    if current_user
      respond_to do |format|
        format.html do
          render :template => 'shared/unauthorized', :status => 401
        end
      end
    else
      redirect_to :controller => :sessions, :action => :new
    end

    false
  end

  def check_for_auth_error!
    yield
  rescue Contenter::Error::Auth => err
    access_denied err.inspect
  end

  def auth_cache_check!
    Garm::AuthorizationCache.current.check!
  end
  private :auth_cache_check!


  def track_user!
    UserTracking.current_user = Proc.new { self.current_user }
    UserTracking.real_user = Proc.new { self.real_user }
    true
  end
  private :track_user!

  
  # If true: 
  # [ login, password ] from HTTP basic auth
  # is considered to be a valid user.
  # Assume that the password is also valid,
  # and store it in the User, if a user exists.
  cattr_accessor :basic_auth_is_authoritative 

  # If true:
  # If a User does not already exist,
  # Create a new User object with the HTTP basic auth
  # [ login, password ]
  # using Contenter::AutoUserCreator.
  #
  # See config/auto_users.yml.
  cattr_accessor :basic_auth_use_auth_user_creator
  
  # Creates a new user with default and content_editor roles.
  def before_basic_auth login, password
    user = nil
    if ApplicationController.basic_auth_is_authoritative 
      if user = User[login]
        # Update password in User.
        unless user.authenticated?(password)
          user.password = password
          user.password_confirmation = password
          user.save!
=begin
          $stderr.puts "user.password         = #{user.password.inspect}"
          $stderr.puts "user.crypted_password = #{user.crypted_password.inspect}"
=end
        end
      end

      if ApplicationController.basic_auth_use_auth_user_creator
        # Create a new user and/or update its roles.
        creator = Contenter::AutoUserCreator.new
        user = creator.create_user!(:user => user, :login => login, :password => password)
      end
    end

    user
  end
  protected :before_basic_auth


  ####################################################################
  # Streamlined support
  #


  def html_title
    "Contenter : #{self.class.name.sub(/Controller$/, '').underscore.humanize.downcase} : #{self.action_name.humanize.downcase}"
  end
  helper_method :html_title


  def __link_to text, opts = { }
    opts[:controller] ||= params[:controller] if opts[:action]

    link = ''
    link << "/#{opts[:controller]}" if opts[:controller]
    link << "/#{opts[:action]}" if opts[:action]
    if x = opts[:id]
      x = x.id if respond_to?(:id)
      link << "/#{x}"
    end

    %Q{<a href="#{link}">#{text}</a>}
  end
  helper_method :__link_to


  def string_pluralize(n, str)
    if n == 1
      "#{n} #{str}"
    else
      "#{n} #{str.pluralize}"
    end
  end
  helper_method :string_pluralize


  def streamlined_branding
    result = ''

    result << %Q{<span><a href="/">Contenter</a></span>}

    result
  end
  helper_method :streamlined_branding


  def top_right_branding
    result = ''
 
    result << %Q{<span style="float: right; font-size: 75%;">}
    if logged_in?
      result << __link_to(current_user.name, :controller => :users, :action => :show, :id => current_user)
      result << ' ' << __link_to(:logout, :controller => :sessions, :action => :destroy)
    else
      result << __link_to(:login, :controller => :sessions, :action => :new)
    end
    if (x = session_version_list) && ! x.empty?
      result << ' </ br> ('
      result << __link_to(string_pluralize(x.size, 'change'), :controller => :my, :action => :changes)
      result << ')'
    end
    result << %Q{</span>}

    result
  end
  helper_method :top_right_branding


  def top_menu_groups
    @top_menu_groups ||=
      [
       [ :content, 'Content', ], 
       [ :axis, 'Axis', ],
       [ :versions, 'Versions' ],
       [ :authorization, 'Authorization', ],
       [ :approval, 'Approval', ],
       [ :api, 'API', ],
       [ :other, 'Other', ],
       [ :UNGROUPED, 'UNGROUPED!', ],
      ]
  end

  def side_menu_groups
    @side_menu_groups ||=
      [
       [ :search, 'Search', ], 
       [ :crud, 'CRUD', ],
       [ :data, 'Data' ],
       [ :workflow, 'Workflow', ],
       [ :preview, 'Preview', ],
       [ :upload, 'Upload/Download', ],
       [ :other, 'Other', ],
       [ :UNGROUPED, 'UNGROUPED!', ],
      ]
  end


  # Subclasses can override this method.
  def _streamlined_top_menus
    menus = [
             { :group => :content, 
               :menus => [
                          [ 'Search',
                            { :controller => :search, :action => :search },
                          ],
                          :content,
                          :content_key,
                          :content_type,
                         ],
             },
             { :group => :axis, 
               :menus => [
                          :language,
                          :country,
                          :brand,
                          :application,
                          :mime_type,                       
                         ],
             },
             { :group => :versions,
               :menus => [
                          :version_list,
                          :version_list_name,
                         ],
             },
             { :group => :approval,
               :menus => [
                          :content_status,
                          [ 'Approve',
                            { :controller => 'workflow', :action => 'list', :status_action => 'approve' }
                          ],
                          [ 'Release',
                            { :controller => 'workflow', :action => 'list', :status_action => 'release' }
                          ],
                          
                         ],
             },
             { :group => :authorization,
               :menus => [
                          :user,
                          :role,
                          :capability,
                          :role_capability,
                          ],
             },
    ]

    menus <<
      [ 'API',
        { :controller => :api, :action => :search },
        :api,
      ]

    menus <<
      [ 'Feeds',
        { :controller => :feeds, :action => :index },
        :other,
      ]

    menus
  end
  helper_method :_streamlined_top_menus


  def top_menu_configuration
    @top_menu_configuration ||=
      begin
        # Collect all top menus.
        menus = _streamlined_top_menus
        
        # Configure groups and menus.
        mc = Contenter::Menu::Configuration.new
        mc.add_groups! top_menu_groups
        mc.add_menus! menus
        
        # Defaults:
        mc.menus.each do | m |
          m.group ||= :other
          # m.link[:action] ||= :list
        end
        
        # Highlight the menu that is current active.
        mc.highlight! do | m |
          m.link[:controller].to_s == params[:controller].to_s
        end
     
        # Select only menus that the User has access to.
        user = current_user || User[:__default__]
        mc.select! do | menu |
          menu_link = menu.link
          # Assume foo/ is really foo/list capability.
          unless menu_link[:action]
            menu_link = menu_link.dup
            menu_link[:action] = :list
          end
          user && user.has_capability?(menu_link)
        end
        
        mc
      end
  end
  helper_method :top_menu_configuration

  def streamlined_top_menus
    @streamlined_top_menus ||=
      top_menu_configuration.menus.map do | m |
        [ m.title, m.link ]
      end
  end
  helper_method :streamlined_top_menus


  def top_menus
    @top_menus ||=
      begin
        top_menu_configuration.grouped
      end
  end
  helper_method :top_menus


  # Subclasses can override this method.
  def _streamlined_side_menus
    menus = [ ]

    menus <<
      [ 'Capability for this page',
        { :controller => 'capabilities', :action => 'who_has', :uri => CGI.escape(request.path) },
      ]

    menus.concat [ :list, :new ]

    # Show id-based actions.
    if params[:id]
      [ :show, :edit ].each do | action |
        menus << [ action, { :action => action, :id => :id } ]
      end
      menus << [ "New from this",
                 { :action => :new, :id => :id } ]

      # See DestroyControllerActions.
      if respond_to?(:destroy_prompt) && params[:action].to_s != "destroy_prompt"
        menus << [ "Destroy",
                 { :action => :destroy_prompt, :id => :id } ]
      end
    end

    menus
  end
  helper_method :_streamlined_side_menus


  def streamlined_side_menus
    menus = _streamlined_side_menus
    
    if respond_to?(:plugin_side_menus)
      x = plugin_side_menus
      menus.concat x if x
    end

    menus.compact! # Remove nils

    menus = menus.map do | x |
      case x
      when Array
        x
      when Symbol, String
        [ x.to_s.humanize, { :action => x } ]
      end
    end

    # Higlight current menu title.
    menus = menus.map do | (title, opts, custom_text, group) |
      title = title.to_s.humanize if Symbol === title
      title = title.to_s
      if action_name == opts[:action].to_s
        title = "<u>#{title}</u>"
      end
      [ title, opts, custom_text, group ]
    end
    
    # Default controller, id.
    menus.each do | (title, opts) |
      opts[:controller] ||= (params[:controller] || self.class.name.sub(/Controller$/).underscore).to_sym
      opts[:id] = params[:id] if opts[:id] == :id
    end


    # Filter out unauthorized menus.
    user = current_user || User[:__default__]
    menus = menus.select do | (title, opts) |
      next true if opts[:html]
      opts = opts.dup
      action = opts[:action].to_s.dup
      # See DestroyControllerActions.
      action.sub!(/\A(.*)_(prompt)\Z/){|x| $1 }
      opts[:action] = action
      result = user && user.has_capability?(opts)
=begin
      $stderr.puts "   user = #{user.name}"
      $stderr.puts "   opts = #{opts.inspect}"
      $stderr.puts "     => #{result.inspect}"
=end
      result
    end

    menus
  end
  helper_method :streamlined_side_menus


  def streamlined_footer
    'www.contenter.org'
  end
  helper_method :streamlined_footer

  # Action we can hit to force an error (only superusers will be able to hit this)
  def _error
    raise ArgumentError, "TEST ERROR"
  end


  # On the way to writing an error to the log file, send us its info
  def log_error(ex) 
    super(ex)

    begin
      unless (recipient = ENV['CONTENTER_ERROR_EMAIL_TO']).blank?
        subject = ENV['CONTENTER_ERROR_EMAIL_SUBJECT'] + " " + ex.message
        body = get_error_info(ex, ENV['CONTENTER_ERROR_EMAIL_BODY'] )
        quick_mail(subject, recipient, body)
      end
    rescue => e
      logger.error(e)
    end
  end
  protected :log_error

  def get_error_info ex, body_lambda=nil
    return eval(body_lambda).pretty_inspect unless body_lambda.blank?

    [
     :time,            Time.now,
     :hostname,        Socket.gethostname,
     :RAILS_ENV,       RAILS_ENV,
     :params,  params,
     :session, session.instance_variable_get("@data"),
     :request_env, request.env,
     :current_user,    current_user,
     :current_user_roles,    current_user.roles.join(","),
     :controller_class, self.class.name, 
     :controller_extended_by, self.extended_by,
     :error_class, ex.class,
     :error,       ex,
     :backtrace,   clean_backtrace(ex),
     :ENV, ENV
    ].pretty_inspect
  end
  protected :get_error_info

  # quick mail handler- no ActionMailer nonsense - for error sending
  def quick_mail(subject, recipient, body)
    stream = IO.popen( "mail -s '#{subject}' #{recipient}", 'w')
    stream.puts(body)
    stream.close
  end
  protected :quick_mail

end
