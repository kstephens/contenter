require 'base64'

require 'contenter/yaml'

module Contenter
  # Represents bulk content.
  class Bulk
    # Options.
    attr_accessor :options

    # The document Hash to be rendered as YAML.
    attr_accessor :document

    # The format to be rendered: :yaml or :csv
    attr_accessor :format

    def initialize options = nil
      options ||= { }
      @options = options
      @format = options[:format]
      @format ||= :yaml
      @document = options[:document] || { }
      @document[:api_version] ||= 1
      @document[:contents_columns] ||=
        [
         :uuid,
         :version,
         :content_status,
         :content_type,
         :content_key,
         :language,
         :country,
         :brand,
         :application,
         :mime_type,
         :updater,
         :tasks,
         :filename,
         :md5sum,
         :data,
        ]
    end


    def contents
      @document[:contents]
    end


    def render fh = nil
      send(:"render_#{format}", fh)
    end

    BASE64 = :'base64'
    RAW = :'raw'
    INDENT = '    '.freeze
    START_ROW = '- - '.freeze
    START_COL = '  - '.freeze
    NEWLINE = "\n".freeze

    def render_csv fh = nil
      fh ||= ''

      require 'fastercsv'
      
      render_header = lambda do | cols |
        fh << FasterCSV.generate_line(cols)
      end

      row = nil
      render_rows(render_header) do | row_i, c, i, v |
        if i == 0
          fh << FasterCSV.generate_line(row) if row
          row = nil
        end
        (row ||= [ ]) << v 
      end
      fh << FasterCSV.generate_line(row) if row

      fh

    rescue Exception => err
      $stderr.puts "#{self.class.name}: ERROR: #{err.inspect}"
      raise err
    end

    # Renders YAML document representing the content
    # as an array of arrays with list of column names.
    def render_yaml fh = nil
      fh ||= StringIO.new

      fh.puts <<"END"
# THIS IS UTF-8 YAML: CHECK YOUR EDITOR SETTINGS BEFORE EDITING IT!
# GENERATED BY #{self.class.name}#render_yaml
--- 
:api_version: #{document[:api_version]}
END
      if x = document[:action]
        fh.puts ":action: #{x.to_s.inspect}" 
      end

      if x = document[:format]
        fh.puts ":format: #{x.to_s.inspect}" 
      end

      if x = document[:comment]
        fh.puts ":comment: #{x.to_s.inspect}" 
      end

      if x = document[:errors]
        fh.puts ":errors: #{x.inspect}" 
      end

      if x = document[:stats]
        fh.puts ":stats:"
        x.keys.sort { | a, b | a.to_s <=> b.to_s }.
        each do | k |
          v = x[k]
          fh.puts "  #{k.inspect}: #{v.inspect}"
        end
      end

      render_header = lambda do | cols |
        fh.puts <<"END"
:contents_count: #{document[:contents_count]}
:contents_columns: #{cols.inspect}
:contents: 
END
      end

      render_rows(render_header) do | row_i, c, i, v |
        if i == 0
          fh.puts "# #{row_i}" if options[:row_id]
          fh.write START_ROW
        else
          fh.write START_COL
        end
      
        case c
        when :data
          fh.write Contenter::Yaml.string_as_yaml(v, INDENT); fh.write NEWLINE
        when :content_key, :data_encoding, :filename
          fh.puts v.inspect
        when :version, :id, :uuid, :content_key_uuid, :md5sum
          fh.puts v.to_s
        when :tasks
          fh.puts "#{v.inspect} \# tasks"
        else
          fh.puts ":#{v.inspect}"
        end
      end

      fh
    end


    def render_rows render_header
      cols = document[:contents_columns] || (raise ArgumentError, 'no contents_columns')

      i = -1
      col_to_i = { }
      cols.each do | c |
        col_to_i[c] = i += 1
      end

      data_i = col_to_i[:data] || 9999
      data_encoding_i = col_to_i[:data_encoding] || (data_i + 1)

      # $stderr.puts "#{document[:contents]}"
      document[:contents_count] = document[:contents].size
      encoded = false
      row_i = -1
      contents = document[:contents] || [ ]
      contents.map! do | r_orig |
        r = r_orig
        row_i += 1
        
        # Transform each content element into
        # an Array.
        case r
        when Hash
          r = cols.map { | c | r[c] }
        when Array
          #
        else
          r = cols.map do | c | 
            r.send(c)
          end
        end
        
        # Check data encoding.
        if r[data_i]
          data_encoding = r[data_encoding_i]
          data_encoding = BASE64 if r_orig.respond_to?(:is_binary?) && r_orig.is_binary? 
          data_encoding &&= data_encoding.to_sym
          case data_encoding
          when nil, RAW
          when BASE64
            encoded = true
            r[data_i] = Base64.encode64(r[data_i])
            r[data_encoding_i] = data_encoding
          else
            raise ArgumentError, "row #{row_i}: unknown encoding: #{data_encoding.inspect}"
          end
        end
        
        r
      end
      
      if encoded
        unless cols.include?(:data_encoding)
          cols = cols.dup
          cols << :data_encoding
        end
      end
      
      render_header.call(cols)
      
      row_i = -1
      contents.each do | r |
        row_i += 1
        cols.each_with_index do | c, i |
          v = r[i]
          
          # Transform any value into a string.
          # $stderr.puts "  [#{row_i}]#[#{c.inspect}] => #{v.inspect}"
          case
          when v.respond_to?(:login)
            v = v.login
          when v.respond_to?(:code)
            v = v.code
          when Symbol === v
          when v.respond_to?(:to_s)
            v = v.to_s
          end
          
          yield row_i, c, i, v
        end
      end
    
      self
    end
  end # class
end # module

